pid /tmp/nginx.pid;

events {
    #required
    worker_connections 1024;
}

http {
    lua_package_path "/usr/local/openresty/lualib/resty/?.lua;;";
    lua_shared_dict jwt_cache 10m;

    proxy_temp_path /tmp/proxy_temp;
    fastcgi_temp_path /tmp/fastcgi_temp;
    uwsgi_temp_path /tmp/uwsgi_temp;
    scgi_temp_path /tmp/scgi_temp;
    client_body_temp_path /tmp/client_temp;

    # Lua script
    init_by_lua_block {
        validate_jwt = function(required_roles)
            local jwt = require "resty.jwt"
            local validators = require "resty.jwt-validators"
            
            -- Load public key
            local public_key = io.open("/etc/secrets/keycloak-public-key", "r"):read("*a")
            if not public_key then
                ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                ngx.say('{"error": "Unable to load public key"}')
                return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
            end

            -- Extract Auth header
            local auth_header = ngx.var.http_authorization
            if not auth_header or not string.find(auth_header, "Bearer") then
                ngx.status = ngx.HTTP_UNAUTHORIZED
                ngx.say('{"error": "Authorization header is missing or invalid"}')
                return ngx.exit(ngx.HTTP_UNAUTHORIZED)
            end

            -- Extract token
            local token = string.gsub(auth_header, "Bearer ", "")

            -- Decode and validate token
            local jwt_obj = jwt:verify(public_key, token, {})

            if not jwt_obj.verified then
                ngx.status = ngx.HTTP_UNAUTHORIZED
                ngx.say('{"error": "Invalid token"}')
                return ngx.exit(ngx.HTTP_UNAUTHORIZED)
            end

            -- Check if token is expired
            local claims = jwt_obj.payload

            local exp = claims["exp"]
            if exp and os.time() > exp then
                ngx.status = ngx.HTTP_UNAUTHORIZED
                ngx.say('{"error": "Token has expired"}')
                return ngx.exit(ngx.HTTP_UNAUTHORIZED)
            end


            -- Exctract claims
            local roles = claims["realm_access"]["roles"] or {}
            local id = claims["sub"]
            local name = claims["name"]
            local groupId = claims["groupId"]
            local user_function = claims["function"]
            local notificationPreference = claims["notificationPreference"]

            -- Check role auth
            local role_found = false
            for _, user_role in ipairs(roles) do
                for _, required_role in ipairs(required_roles) do
                    if user_role == required_role then
                        role_found = true
                        break
                    end
                end
                if role_found then
                    break
                end
            end

            if not role_found then
                ngx.status = ngx.HTTP_FORBIDDEN
                ngx.say('{"error": "Insufficient permissions"}')
                return ngx.exit(ngx.HTTP_FORBIDDEN)
            end

            -- Forward request with claims in header
            ngx.req.set_header("X-User-Roles", table.concat(roles, ","))
            ngx.req.set_header("X-User-Id", id)
            ngx.req.set_header("X-User-Name", name)
            ngx.req.set_header("X-User-GroupId", groupId)
            ngx.req.set_header("X-User-Function", user_function)
            ngx.req.set_header("X-User-NotificationPreference", notificationPreference)
        end

    }

    upstream faq-service {
        server sail-faq-api-service:80;
    }

    upstream map-service {
        server sail-map-api-service:80;
    }

    upstream user-service {
        server sail-user-service:8080;
    }

    server {
        listen 8080;

        location /login {
            rewrite ^/login(/.*)$ $1 break;
            proxy_pass http://keycloak-route-oscar-dev.apps.inholland.hcs-lab.nl/realms/sail-amsterdam/protocol/openid-connect/token;
        }

        location /faq {
            access_by_lua_block {
                validate_jwt({"team-lead"})

                ngx.log(ngx.ERR, "Request method: ", ngx.var.request_method)
                ngx.log(ngx.ERR, "Request URI: ", ngx.var.request_uri)
                ngx.log(ngx.ERR, "Request headers: ")
                for k, v in pairs(ngx.req.get_headers()) do
                    ngx.log(ngx.ERR, k, ": ", v)
                end
            }

            rewrite ^/faq(/.*)$ $1 break;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_pass http://faq-service;

        }

        location /map {
            access_by_lua_block {
                validate_jwt({"team-lead", "admin"})
            }

            rewrite ^/map(/.*)$ $1 break;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_pass http://map-service;
        }

        location /user {
            access_by_lua_block {
                validate_jwt("volunteer")
            }

            rewrite ^/user(/.*)$ $1 break;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_pass http://user-service;
        }

        #Moc /test route
        location /test {
            return 200 '{"message": "Hello, World!"}';
            add_header Content-Type application/json;
        }
    }
}